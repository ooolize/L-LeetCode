### 题目
[ Best Time to Buy and Sell Stock with Cooldown](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/submissions/)
### 思路
0ms 100%

每一天都可能有三个状态。
+ sell[i]:第i天可能无操作（观望）或者卖出
+ buy[i]:第i天可能无操作（观望）或者买入
+ cold[i]:第i天可能无操作（观望）或者冷冻

> cold[i]=cold[i-1]并不是说连续两天冰冻，只是该天无操作，仅更新信息(以备之后buy用)。于是i-1表示我们上一次使用冷冻操作，而不是昨天。
>
> 如果没有sell操作，buy和cold都应该保持上一次的值。即buy[i]=buy[i-1];cold[i]=cold[i-1];

+ cold[i]=max(cold[i-1],sell[i-1]); 如果新的冷冻期的利润比上一次的高，就更新cold
+ buy[i]=max(buy[i-1],cold[i-1]-prices[i]);如果在上一次冷冻期后出现很小的值，就更新buy
+ sell[i]=max(sell[i-1],buy[i-1]+prices[i]); 如果在上一次购买后出现较大的值，就更新sell


### 代码

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size()==0) return 0;
        int n=prices.size();
        vector<int> sell(n,0);
        vector<int> buy(n,0);
        vector<int> cold(n,0);
        buy[0]-=prices[0];
        for(int i=1;i<n;i++){
            sell[i]=max(sell[i-1],buy[i-1]+prices[i]);
            buy[i]=max(buy[i-1],cold[i-1]-prices[i]);
            cold[i]=max(cold[i-1],sell[i-1]);
        }
        return sell[n-1];
    }
};
```
