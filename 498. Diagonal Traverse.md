### 题目
[498. Diagonal Traverse](https://leetcode-cn.com/problems/diagonal-traverse/solution/)
### 思路
576ms 5.81%

行列和为n的是一组对角。

100ms 68.09%

不整那些花里胡哨的了直接遍历。不过内存使用还是太差。
### 代码
直接遍历
```c++
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
	int m = matrix.size();
	if (m == 0)return {};
	if (m == 1)return matrix.back();
	int n = matrix.back().size();
    int size=max(m,n);
	vector<vector<int>> res(2*size-1,vector<int>());
    vector<int> ans;
        
    for(int i=0;i<m;i++){
        for(int j=0;j<n;j++){
            res[i+j].push_back(matrix[i][j]);
        }
    }
    for(int i=0;i<res.size();i++){
        if(i%2==0)reverse(res[i].begin(),res[i].end());
        for(auto p:res[i])
            ans.push_back(p);
    }
    return ans;
}

};
```

```c++
class Solution {
public:
    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {
	vector<int> res;
	int m = matrix.size();
	if (m == 0)return res;
	if (m == 1)return matrix.back();
	int n = matrix.back().size();
	int size = max(m, n);
	int total = size * 2 - 1;

	for (int i = 0; i<total; i++){
		vector<int> tmp;
		for (int j = 0; j<size; j++){
			int r = j, c = i - j;
			if (r<m&&c >= 0 && c<n)
				tmp.push_back(matrix[r][c]);
		}
		if (i % 2==0)reverse(tmp.begin(), tmp.end());

		for (auto p : tmp)
			res.push_back(p);
	}
	return res;
}

};
```
