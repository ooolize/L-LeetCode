### 题目
[343. Integer Break](https://leetcode-cn.com/problems/integer-break/)
### 思路
8ms 30.32%
动态规划做。 我们求的是最大积的划分方法。

比如x1=a1+b1,如果此时它的积最大，即x1=a1+b1，最大积为a1b1。

同时x2=a2+b2,如果此时它的积最大，即x2=a2+b2,最大积为a2b2。

当有一个值的一种划分方法为x3=x1+x2时，如果它是所有划分中最大积，那么x3的最大积为a1a2b1b2.

说了这么多，其实就是说可以用前面的算后面的，有点裴波那契数列的意思。

+ 注意有两个特殊情况，a[2],a[3]

0ms 100%
我教弟弟写的,hhh
### 代码
```c++
class Solution {
public:
    int integerBreak(int n) {
        if(n==2) return 1;
        if(n==3) return 2;
        vector<int> a(n+1,0);
        a[1]=1;a[2]=2;a[3]=3;
        for(int i=4;i<=n;i++){
            for(int j=1;j<=i/2;j++){
                a[i]=max(a[i],a[j]*a[i-j]);
            }
        }
        return a[n];
    }
};
```

```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> res{0,1,1,2,4,6,9,12,18,27,36,54,81,108,162,243,
        324,486,729,972,1458,2187,2916,4374,6561,8748,13122,19683,26244,
        39366,59049,78732,118098,177147,236196,354294,531441,708588,1062882,
        1594323,2125764,3188646,4782969,6377292,9565938,14348907,19131876,
        28697814,43046721,57395628,86093442,129140163,172186884,258280326,
        387420489,516560652,774840978,1162261467,1549681956};
        return res[n];
    }
};
```
---
# Todo
+ 排名不算很好。应有其他[简便方法](https://leetcode-cn.com/problems/integer-break/comments/90712).这个动规只用了o(n)时间
