### 题目
[449. Serialize and Deserialize BST](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/solution/)
### 思路
看题解知，对于BST我们只需要用前序遍历就可以复原树。

每次找到第一个比节点大的数就是右子树的起点，其余就是左子树。

第一次做的时候没有意识到先把数组处理一下比较好。怎么都没过去
### 代码
未AC代码
```c++
class Codec {
public:
    void VLR(TreeNode*root,string&s){
        if(root==NULL){s+="null.";return;}
        
        s+=to_string(root->val);
        s.push_back('.');
        
        if(root->left==NULL&&root->right==NULL) return;
        VLR(root->left,s);
        VLR(root->right,s);
        
        return;
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string s;
        if(root)VLR(root,s);
        return s;
    }
    
    int up_t(string& data,int k,int l,int r){
        for(int i=l;i<r;i++){
            if(data[i]=='.') continue;
            string p;
            for(int j=i;j<data.size();j++){
                if(data[j]=='.') break;
                p.push_back(data[j]);
            }
            if(p=="null") continue;
            if(stoi(p)>k) return i;
        }
        return -1;
    }
    TreeNode* build_tree(string& data,int l,int r){
        int k=l;
        while(data[k]!='.') k++;
        
        string s=data.substr(l,k-l);
        if(s=="null"){
            return NULL;
        }
        int t=stoi(s);
        int q=up_t(data,t,l,r);
        
        TreeNode* tmp=new TreeNode(t);
        if(q==-1) return tmp;
        tmp->left=build_tree(data,l+s.size()+1,q-1);
        tmp->right=build_tree(data,q,r);
        return tmp;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if(!data.empty())
            return build_tree(data,0,data.size()-1);
        return NULL;
    }
};
```
