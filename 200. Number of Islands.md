### 题目
[200. Number of Islands](https://leetcode-cn.com/problems/number-of-islands/submissions/)
### 思路
本来想遍历每个位置如果为1用BFS将整块‘1’变为0，否则继续循环。结果38/47就超时了。

后来看了评论，如果入队列时就把该位置置零，将会节约很多时间。有时候出现
### 代码
```c++
class Solution {
public:
    void explore(int cur, int n, int m, vector<vector<char>>& grid,
	 vector<int>& dr, vector<int>&dl){
	 queue<int> q;
	 q.push(cur);
	 while (!q.empty()){
		 int k = q.front();
		 q.pop();
		 int r = k / n;
		 int l = k%n;
		 grid[r][l] = '0';
		 for (int i = 0; i<4; i++){
			 int next_r = r + dr[i];
			 int next_l = l + dl[i];
			 if (next_r >= 0 && next_l >= 0 && next_r<m&&next_l<n&&grid[next_r][next_l]!='0'){
				 q.push(next_r*n + next_l);
			 }
		 }

	 }
	 return;
 }

 int numIslands(vector<vector<char>>& grid) {
	 int m = grid.size();
	 if (m == 0) return 0;
	 int n = grid.back().size(), ans = 0;
	 vector<int> dr{ 0, 1, 0, -1 };
	 vector<int> dl{ 1, 0, -1, 0 };

	 for (int cur = 0; cur<m*n; cur++){
		 int r = cur / n;
		 int l = cur%n;
		 if (grid[r][l] == '0')continue;
		 else{
			 explore(cur, n, m, grid, dr, dl);
			 ans++;
		 }
	 }
	 return  ans;
 }  
 
};
```
