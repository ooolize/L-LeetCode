### 题目
[5. Longest Palindromic Substring](https://leetcode-cn.com/problems/longest-palindromic-substring/submissions/)
### 思路
53/103 error:超时

刚开始做用暴力法，遍历嵌套组成[i,j]区间，再遍历一次[i,j]的元素判断是否是回文，O(n^3) 

736ms 5.01%

这道题还是很经典的，方法很多。

+ 采用了一个二维布尔数组存储子字符串[i,j]是否是回文串
+ 从尾到首逐步构造，如果是回文就将该位置a[i][j]置位。
+ 平常的回文是要判断首尾元素。有两个特殊回文是形如a,aa这样本身长度小于3的。不用比较它的首尾元素，直接返回置位。
### 代码
```c++
class Solution {
public:
        bool is_pra(string& s){
            int l=0,r=s.size()-1;
            while(l<=r){
                if(s[l++]!=s[r--]) return false;
            }
            return true;
        }
         string longestPalindrome(string s) {
         int n = s.size();
         string ans;
         for (int i = 0; i<n; i++){
             for(int j=i;j<n;j++){
                 string tmp=s.substr(i,j-i+1);
                 if(is_pra(tmp)&&tmp.size()>ans.size())
                     ans=tmp;
             }
        }
         return ans;
     }

};
```

从底向上的动态规划
```c++
class Solution {
public:
    string longestPalindrome(string s) {
        int n=s.size();
        vector<vector<bool>> a(n,vector<bool>(n,false));
        string ans="";
        for(int i=n-1;i>=0;i--){
            for(int j=i;j<n;j++){
                if(s[i]==s[j])
                    a[i][j]=(j-i<2)||a[i+1][j-1];
                if(a[i][j]&&j-i+1>ans.size()) 
                    ans=s.substr(i,j-i+1);
            }
        }
        return ans;
    }
};
```
