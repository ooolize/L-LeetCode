### 题目
[Spiral Matrix.md](https://leetcode-cn.com/problems/spiral-matrix/)
### 思路
来了 来了 丑陋的我又来了...9.32% 12ms

+ 用k表示移动方向，对每个移动方向，一般情况和转向点更新cur的方法不同，通过判断到达边界来判断是否该转向。

+ 特殊情况是空向量，单独列出即可

这种矩阵形式 cur应该从0开始，这样cur/n表示行号，cur%n表示列号

还有一个惨痛的经验就是一定是先做对 再优化，不然来来回回的改太费时了。
### 代码
```c++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
		 // vector<string> orient{"right","down","left","up"};
         
		 int m = matrix.size();
     if(m==0) return vector<int>(); 
		 if (m == 1 ) return matrix.back();
     int n = matrix.back().size(), k = 0;
		 size_t cur = 0;
		 vector<int> s;

		 
		 while (true){
			 k = k % 4;
			 int tmp = cur;
			 if (k == 0){
				 while (find(s.begin(), s.end(), matrix[cur / n][cur % n]) == s.end()) { //规则检查
					 s.push_back(matrix[cur / n][cur % n]);
					 if (cur %n == n - 1 ||
						 find(s.begin(), s.end(), matrix[(cur + 1) / n][(cur + 1) % n]) != s.end()) {
						 cur += n; 
						 break;
					 }
					 cur++;
				 }
			 }
			 if (k == 1){
				 while (find(s.begin(), s.end(), matrix[cur / n][cur % n]) == s.end()) { //规则检查
					 s.push_back(matrix[cur / n][cur % n]);
					 if (cur / n == m-1 ||
						 find(s.begin(), s.end(), matrix[(cur + n) / n][(cur + n) % n]) != s.end()){
						 cur--; 
						 break;
					 }
					 cur += n;
				 }
			 }
			 if (k == 2){
				 while (find(s.begin(), s.end(), matrix[cur / n][cur % n]) == s.end()) { //规则检查
					 s.push_back(matrix[cur / n][cur % n]);
					 if (cur%n == 0 ||
						 find(s.begin(), s.end(), matrix[(cur -1) / n][(cur - 1) % n]) != s.end()){
						 cur -= n; 
						 break;
					 }
					 cur--;
				 }
			 }
			 if (k == 3){
				 while (find(s.begin(), s.end(), matrix[cur / n][cur % n]) == s.end()) { //规则检查
					 s.push_back(matrix[cur / n][cur % n]);
					 if (cur / n == 0 ||
						 find(s.begin(), s.end(), matrix[(cur - n) / n][(cur - n) % n]) != s.end()){
						 cur++;
						 break;
					 }
					 cur -= n;
				 }
			 }
			 if (tmp == cur) break;
			 k++;
		 }
		return s;

}

};
```
