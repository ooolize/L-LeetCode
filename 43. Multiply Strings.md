## 题目
[43. Multiply Strings](https://leetcode-cn.com/problems/multiply-strings/)
## 思路
就是模仿多位数与多位数的乘法。

然后出现了一个想不通的点，n传递有问题
## 代码
```c++
string multiply(string num1, string num2) {
	if (num1.size()<num2.size()) return multiply(num2, num1);

	vector<int> v1, v2, result;
	string ans("");
	push_string(v1, num1);
	push_string(v2,num2);

	while (!v2.empty()){
		int i = v2.back(), n = 0;
		result = add_two(result, multi(i, v1, n), n);//这里n传递有问题，按理说multi函数是传递的索引，n在其中
                                                 //更新，然后到add_two函数是更新后的n，但实际上不是
	}

	while (!result.empty()){
		ans += result.back();
		result.pop_back();
	}
	return ans;
}
void push_string(vector<int>&v, string num){
	for (auto& p : num)
		v.push_back(p - '0');
}

vector<int> multi(int i, vector<int> v, int& n){
	vector<int> result;
	int k = 0, carry = 0;
	while(!v.empty()){
		int p = v.back();
		k = p*i + carry;
		result.push_back(k % 10);
		carry = k / 10;
		v.pop_back();
	}
	if (carry) result.push_back(carry);
	n++;
	reverse(result.begin(), result.end());
	return result;
}

vector<int> add_two(vector<int>&v1, vector<int>&v2, int n){
	int k = n, carry = 0;
	vector<int> result;
	while (k--){
		result.push_back(v1.back());
		v1.pop_back();
	}
	while (!v2.empty()){
		if (v1.empty()) k = 0;
		else {
			k = v1.back();
			v1.pop_back();
		}
		k = v2.back() + carry;
		result.push_back(k % 10);
		carry = k % 10;
		v2.pop_back();
	}

	if (carry) result.push_back(carry);
	return result;

}

```
