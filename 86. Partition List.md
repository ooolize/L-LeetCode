### 题目
[Partition List](https://leetcode-cn.com/problems/partition-list/submissions/)
### 思路
思路一 12ms 68.33% 有点繁琐，细节很多。遍历一次每次寻找一个>=x的节点cur，找到后从该节点开始往后寻找一个<x的节点tmp，

+ 如果可以找到就把它放在节点cur的前面，为了完成指针更新操作，我们为cur，tmp设置了跟随指针pred1,pred2。
+ 如果没找到说明后面都是大于x的，直接返回即可。

em... 后来一想，可以直接设置两个指针一次遍历分割成两块 然后直接相连就好
### 代码
思路一

```c++
class Solution {
public:
    
   ListNode* partition(ListNode* head, int x) {
	 if (head == NULL)return head;
	 ListNode* pred1 = new ListNode(-1), *cur = head, *tmp = head, *pred2 = head;
	 pred1->next = head;

	 while (cur){
		 if (cur->val >= x){
			 tmp = cur;
			 pred2 = pred1;
			 while (tmp != NULL&&tmp->val >= x) { pred2 = tmp; tmp = tmp->next; }//寻找tmp(pred2)
			 if (tmp == NULL) return head;//没找到<x的节点，直接返回
			 else {
				 pred2->next = tmp->next;
				 if (pred1->next == head)head = tmp;//如果在首部位置就有>=x的，那就要更新head
				 pred1->next = tmp;
				 tmp->next = cur;

			 }
			 pred1 = pred1->next;
		 }
		 else{
			 pred1 = cur;
			 cur = cur->next;
		 }
	 }
	 return head;
 }

};
```
